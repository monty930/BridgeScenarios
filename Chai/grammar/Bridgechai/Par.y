-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Bridgechai.Par
  ( happyError
  , myLexer
  , pProg
  ) where

import Prelude

import qualified Bridgechai.Abs
import Bridgechai.Lex

}

%name pProg Prog
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'         { PT _ (TS _ 1)  }
  '!='        { PT _ (TS _ 2)  }
  '('         { PT _ (TS _ 3)  }
  ')'         { PT _ (TS _ 4)  }
  '+'         { PT _ (TS _ 5)  }
  ','         { PT _ (TS _ 6)  }
  '.'         { PT _ (TS _ 7)  }
  ':'         { PT _ (TS _ 8)  }
  ';'         { PT _ (TS _ 9)  }
  '<'         { PT _ (TS _ 10) }
  '<='        { PT _ (TS _ 11) }
  '='         { PT _ (TS _ 12) }
  '=='        { PT _ (TS _ 13) }
  '>'         { PT _ (TS _ 14) }
  '>='        { PT _ (TS _ 15) }
  'E'         { PT _ (TS _ 16) }
  'N'         { PT _ (TS _ 17) }
  'S'         { PT _ (TS _ 18) }
  'W'         { PT _ (TS _ 19) }
  '['         { PT _ (TS _ 20) }
  '[2]'       { PT _ (TS _ 21) }
  '[3]'       { PT _ (TS _ 22) }
  '[4]'       { PT _ (TS _ 23) }
  '[5]'       { PT _ (TS _ 24) }
  '[6]'       { PT _ (TS _ 25) }
  '[7]'       { PT _ (TS _ 26) }
  '[8]'       { PT _ (TS _ 27) }
  '[9]'       { PT _ (TS _ 28) }
  '[A]'       { PT _ (TS _ 29) }
  '[J]'       { PT _ (TS _ 30) }
  '[K]'       { PT _ (TS _ 31) }
  '[Q]'       { PT _ (TS _ 32) }
  '[T]'       { PT _ (TS _ 33) }
  ']'         { PT _ (TS _ 34) }
  'and'       { PT _ (TS _ 35) }
  'c'         { PT _ (TS _ 36) }
  'd'         { PT _ (TS _ 37) }
  'evaluator' { PT _ (TS _ 38) }
  'false'     { PT _ (TS _ 39) }
  'final'     { PT _ (TS _ 40) }
  'h'         { PT _ (TS _ 41) }
  'int'       { PT _ (TS _ 42) }
  'length'    { PT _ (TS _ 43) }
  'not'       { PT _ (TS _ 44) }
  'or'        { PT _ (TS _ 45) }
  'predeal'   { PT _ (TS _ 46) }
  's'         { PT _ (TS _ 47) }
  'true'      { PT _ (TS _ 48) }
  '{'         { PT _ (TS _ 49) }
  '}'         { PT _ (TS _ 50) }
  L_Ident     { PT _ (TV $$)   }
  L_integ     { PT _ (TI $$)   }
  L_quoted    { PT _ (TL $$)   }

%%

Ident :: { Bridgechai.Abs.Ident }
Ident  : L_Ident { Bridgechai.Abs.Ident $1 }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Prog :: { Bridgechai.Abs.Prog }
Prog : ListTopDef { Bridgechai.Abs.Program $1 }

TopDef :: { Bridgechai.Abs.TopDef }
TopDef
  : 'predeal' '=' '{' ListHandPredeal '}' { Bridgechai.Abs.TopDefPredeal $4 }
  | 'final' '=' Expr { Bridgechai.Abs.Final $3 }
  | ShapeDef { Bridgechai.Abs.TopDefShape $1 }
  | Ident '=' 'evaluator' '(' ListEvalVal ')' { Bridgechai.Abs.TopDefEval $1 $5 }
  | Ident '=' '(' HoldingExpr ')' { Bridgechai.Abs.TopDefBool $1 $4 }

ListTopDef :: { [Bridgechai.Abs.TopDef] }
ListTopDef
  : {- empty -} { [] }
  | TopDef { (:[]) $1 }
  | TopDef ';' ListTopDef { (:) $1 $3 }

ListHandPredeal :: { [Bridgechai.Abs.HandPredeal] }
ListHandPredeal
  : {- empty -} { [] }
  | HandPredeal { (:[]) $1 }
  | HandPredeal ',' ListHandPredeal { (:) $1 $3 }

HandPredeal :: { Bridgechai.Abs.HandPredeal }
HandPredeal
  : Hand ':' HandFeature { Bridgechai.Abs.HandPredeal $1 $3 }

HandFeature :: { Bridgechai.Abs.HandFeature }
HandFeature
  : String { Bridgechai.Abs.HandLit $1 }
  | '(' Ident ')' { Bridgechai.Abs.SmartStackShape $2 }
  | '(' Ident ',' Ident ',' Integer ')' { Bridgechai.Abs.SmartStackFunc $2 $4 $6 }
  | '(' Ident ',' Ident ',' Value ')' { Bridgechai.Abs.SmartStackFull $2 $4 $6 }

Value :: { Bridgechai.Abs.Value }
Value
  : '(' Integer ',' Integer ')' { Bridgechai.Abs.ValueRange $2 $4 }

ShapeDef :: { Bridgechai.Abs.ShapeDef }
ShapeDef
  : Ident '=' '(' ShapeExpr ')' { Bridgechai.Abs.ShapeCond $1 $4 }
  | Ident '=' ListShape { Bridgechai.Abs.ShapeLit $1 $3 }

EvalVal :: { Bridgechai.Abs.EvalVal }
EvalVal : Integer { Bridgechai.Abs.EvalVal $1 }

ListEvalVal :: { [Bridgechai.Abs.EvalVal] }
ListEvalVal
  : {- empty -} { [] }
  | EvalVal { (:[]) $1 }
  | EvalVal ',' ListEvalVal { (:) $1 $3 }

Shape :: { Bridgechai.Abs.Shape }
Shape
  : ShapeOk { Bridgechai.Abs.ShapeOk $1 }
  | ShapeNeg { Bridgechai.Abs.ShapeNeg $1 }

ShapeOk :: { Bridgechai.Abs.ShapeOk }
ShapeOk : '[' ListSuitCount ']' { Bridgechai.Abs.OneShapeOk $2 }

ShapeNeg :: { Bridgechai.Abs.ShapeNeg }
ShapeNeg : '!' ShapeOk { Bridgechai.Abs.OneShapeNeg $2 }

ListShape :: { [Bridgechai.Abs.Shape] }
ListShape
  : {- empty -} { [] }
  | Shape { (:[]) $1 }
  | Shape '+' ListShape { (:) $1 $3 }

SuitCount :: { Bridgechai.Abs.SuitCount }
SuitCount
  : SuitInt { Bridgechai.Abs.SuitIntCount $1 }
  | '(' ListSuitInt ')' { Bridgechai.Abs.SuitChoice $2 }

SuitInt :: { Bridgechai.Abs.SuitInt }
SuitInt : Integer { Bridgechai.Abs.SuitInt $1 }

ListSuitCount :: { [Bridgechai.Abs.SuitCount] }
ListSuitCount
  : {- empty -} { [] }
  | SuitCount { (:[]) $1 }
  | SuitCount ';' ListSuitCount { (:) $1 $3 }

ListSuitInt :: { [Bridgechai.Abs.SuitInt] }
ListSuitInt
  : {- empty -} { [] }
  | SuitInt { (:[]) $1 }
  | SuitInt ';' ListSuitInt { (:) $1 $3 }

Type :: { Bridgechai.Abs.Type }
Type : 'int' { Bridgechai.Abs.Int }

Expr6 :: { Bridgechai.Abs.Expr }
Expr6
  : Hand '.' Ident { Bridgechai.Abs.HandAttr $1 $3 }
  | Integer { Bridgechai.Abs.ELitInt $1 }
  | 'true' { Bridgechai.Abs.ELitTrue }
  | 'false' { Bridgechai.Abs.ELitFalse }
  | '(' Expr ')' { $2 }

Expr5 :: { Bridgechai.Abs.Expr }
Expr5 : 'not' Expr6 { Bridgechai.Abs.ENot $2 } | Expr6 { $1 }

Expr2 :: { Bridgechai.Abs.Expr }
Expr2
  : Expr2 RelOp Expr3 { Bridgechai.Abs.ERel $1 $2 $3 } | Expr3 { $1 }

Expr1 :: { Bridgechai.Abs.Expr }
Expr1
  : Expr2 'and' Expr1 { Bridgechai.Abs.EAnd $1 $3 } | Expr2 { $1 }

Expr :: { Bridgechai.Abs.Expr }
Expr : Expr1 'or' Expr { Bridgechai.Abs.EOr $1 $3 } | Expr1 { $1 }

Expr3 :: { Bridgechai.Abs.Expr }
Expr3 : Expr4 { $1 }

Expr4 :: { Bridgechai.Abs.Expr }
Expr4 : Expr5 { $1 }

Hand :: { Bridgechai.Abs.Hand }
Hand
  : 'N' { Bridgechai.Abs.HandN }
  | 'E' { Bridgechai.Abs.HandE }
  | 'W' { Bridgechai.Abs.HandW }
  | 'S' { Bridgechai.Abs.HandS }

ShapeExpr6 :: { Bridgechai.Abs.ShapeExpr }
ShapeExpr6
  : SuitLit { Bridgechai.Abs.ESuit $1 }
  | Integer { Bridgechai.Abs.EShapeInt $1 }
  | '(' ShapeExpr ')' { $2 }

ShapeExpr5 :: { Bridgechai.Abs.ShapeExpr }
ShapeExpr5
  : 'not' ShapeExpr6 { Bridgechai.Abs.ENotShape $2 }
  | ShapeExpr6 { $1 }

ShapeExpr2 :: { Bridgechai.Abs.ShapeExpr }
ShapeExpr2
  : ShapeExpr2 RelOp ShapeExpr3 { Bridgechai.Abs.ERelShape $1 $2 $3 }
  | ShapeExpr3 { $1 }

ShapeExpr1 :: { Bridgechai.Abs.ShapeExpr }
ShapeExpr1
  : ShapeExpr2 'and' ShapeExpr1 { Bridgechai.Abs.EAndShape $1 $3 }
  | ShapeExpr2 { $1 }

ShapeExpr :: { Bridgechai.Abs.ShapeExpr }
ShapeExpr
  : ShapeExpr1 'or' ShapeExpr { Bridgechai.Abs.EOrShape $1 $3 }
  | ShapeExpr1 { $1 }

ShapeExpr3 :: { Bridgechai.Abs.ShapeExpr }
ShapeExpr3 : ShapeExpr4 { $1 }

ShapeExpr4 :: { Bridgechai.Abs.ShapeExpr }
ShapeExpr4 : ShapeExpr5 { $1 }

SuitLit :: { Bridgechai.Abs.SuitLit }
SuitLit
  : 's' { Bridgechai.Abs.SuitLitS }
  | 'h' { Bridgechai.Abs.SuitLitH }
  | 'd' { Bridgechai.Abs.SuitLitD }
  | 'c' { Bridgechai.Abs.SuitLitC }

HoldingExpr5 :: { Bridgechai.Abs.HoldingExpr }
HoldingExpr5
  : 'length' { Bridgechai.Abs.HExprLen }
  | Integer { Bridgechai.Abs.HExprInt $1 }
  | Card { Bridgechai.Abs.HExprCard $1 }
  | '(' HoldingExpr ')' { $2 }

HoldingExpr4 :: { Bridgechai.Abs.HoldingExpr }
HoldingExpr4
  : 'not' HoldingExpr5 { Bridgechai.Abs.HNotExpr $2 }
  | HoldingExpr5 { $1 }

HoldingExpr2 :: { Bridgechai.Abs.HoldingExpr }
HoldingExpr2
  : HoldingExpr2 RelOp HoldingExpr3 { Bridgechai.Abs.HRelExpr $1 $2 $3 }
  | HoldingExpr3 { $1 }

HoldingExpr1 :: { Bridgechai.Abs.HoldingExpr }
HoldingExpr1
  : HoldingExpr2 'and' HoldingExpr1 { Bridgechai.Abs.HAndExpr $1 $3 }
  | HoldingExpr2 { $1 }

HoldingExpr :: { Bridgechai.Abs.HoldingExpr }
HoldingExpr
  : HoldingExpr1 'or' HoldingExpr { Bridgechai.Abs.HOrExpr $1 $3 }
  | HoldingExpr1 { $1 }

HoldingExpr3 :: { Bridgechai.Abs.HoldingExpr }
HoldingExpr3 : HoldingExpr4 { $1 }

Card :: { Bridgechai.Abs.Card }
Card
  : '[A]' { Bridgechai.Abs.CardA }
  | '[K]' { Bridgechai.Abs.CardK }
  | '[Q]' { Bridgechai.Abs.CardQ }
  | '[J]' { Bridgechai.Abs.CardJ }
  | '[T]' { Bridgechai.Abs.CardT }
  | '[9]' { Bridgechai.Abs.Card9 }
  | '[8]' { Bridgechai.Abs.Card8 }
  | '[7]' { Bridgechai.Abs.Card7 }
  | '[6]' { Bridgechai.Abs.Card6 }
  | '[5]' { Bridgechai.Abs.Card5 }
  | '[4]' { Bridgechai.Abs.Card4 }
  | '[3]' { Bridgechai.Abs.Card3 }
  | '[2]' { Bridgechai.Abs.Card2 }

RelOp :: { Bridgechai.Abs.RelOp }
RelOp
  : '<' { Bridgechai.Abs.LTH }
  | '<=' { Bridgechai.Abs.LE }
  | '>' { Bridgechai.Abs.GTH }
  | '>=' { Bridgechai.Abs.GE }
  | '==' { Bridgechai.Abs.EQU }
  | '!=' { Bridgechai.Abs.NE }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

