-- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Bridgechai.Skel where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified Bridgechai.Abs

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transIdent :: Bridgechai.Abs.Ident -> Result
transIdent x = case x of
  Bridgechai.Abs.Ident string -> failure x

transProg :: Show a => Bridgechai.Abs.Prog' a -> Result
transProg x = case x of
  Bridgechai.Abs.Program _ topdefs -> failure x

transTopDef :: Show a => Bridgechai.Abs.TopDef' a -> Result
transTopDef x = case x of
  Bridgechai.Abs.TopDefPredeal _ handpredeals -> failure x
  Bridgechai.Abs.Final _ expr -> failure x
  Bridgechai.Abs.TopDefShape _ shapedef -> failure x
  Bridgechai.Abs.TopDefEval _ ident evalvals -> failure x
  Bridgechai.Abs.TopDefHold _ ident holdingexpr -> failure x

transHandPredeal :: Show a => Bridgechai.Abs.HandPredeal' a -> Result
transHandPredeal x = case x of
  Bridgechai.Abs.HandPredeal _ hand handfeature -> failure x

transHandFeature :: Show a => Bridgechai.Abs.HandFeature' a -> Result
transHandFeature x = case x of
  Bridgechai.Abs.HandLit _ string -> failure x
  Bridgechai.Abs.SmartStackShape _ ident -> failure x
  Bridgechai.Abs.SmartStackFunc _ ident1 ident2 integer -> failure x
  Bridgechai.Abs.SmartStackFull _ ident1 ident2 value -> failure x

transValue :: Show a => Bridgechai.Abs.Value' a -> Result
transValue x = case x of
  Bridgechai.Abs.ValueRange _ integer1 integer2 -> failure x

transShapeDef :: Show a => Bridgechai.Abs.ShapeDef' a -> Result
transShapeDef x = case x of
  Bridgechai.Abs.ShapeCond _ ident shapeexpr -> failure x
  Bridgechai.Abs.ShapeLit _ ident shapes -> failure x

transEvalVal :: Show a => Bridgechai.Abs.EvalVal' a -> Result
transEvalVal x = case x of
  Bridgechai.Abs.EvalVal _ integer -> failure x

transShape :: Show a => Bridgechai.Abs.Shape' a -> Result
transShape x = case x of
  Bridgechai.Abs.ShapeOk _ shapeok -> failure x
  Bridgechai.Abs.ShapeNeg _ shapeneg -> failure x

transShapeOk :: Show a => Bridgechai.Abs.ShapeOk' a -> Result
transShapeOk x = case x of
  Bridgechai.Abs.OneShapeOk _ suitcounts -> failure x

transShapeNeg :: Show a => Bridgechai.Abs.ShapeNeg' a -> Result
transShapeNeg x = case x of
  Bridgechai.Abs.OneShapeNeg _ shapeok -> failure x

transSuitCount :: Show a => Bridgechai.Abs.SuitCount' a -> Result
transSuitCount x = case x of
  Bridgechai.Abs.SuitIntCount _ suitint -> failure x
  Bridgechai.Abs.SuitChoice _ suitints -> failure x

transSuitInt :: Show a => Bridgechai.Abs.SuitInt' a -> Result
transSuitInt x = case x of
  Bridgechai.Abs.SuitInt _ integer -> failure x

transType :: Show a => Bridgechai.Abs.Type' a -> Result
transType x = case x of
  Bridgechai.Abs.Int _ -> failure x

transExpr :: Show a => Bridgechai.Abs.Expr' a -> Result
transExpr x = case x of
  Bridgechai.Abs.HandAttr _ hand ident -> failure x
  Bridgechai.Abs.ELitInt _ integer -> failure x
  Bridgechai.Abs.ELitTrue _ -> failure x
  Bridgechai.Abs.ELitFalse _ -> failure x
  Bridgechai.Abs.ENot _ expr -> failure x
  Bridgechai.Abs.ERel _ expr1 relop expr2 -> failure x
  Bridgechai.Abs.EAnd _ expr1 expr2 -> failure x
  Bridgechai.Abs.EOr _ expr1 expr2 -> failure x

transHand :: Show a => Bridgechai.Abs.Hand' a -> Result
transHand x = case x of
  Bridgechai.Abs.HandN _ -> failure x
  Bridgechai.Abs.HandE _ -> failure x
  Bridgechai.Abs.HandW _ -> failure x
  Bridgechai.Abs.HandS _ -> failure x

transShapeExpr :: Show a => Bridgechai.Abs.ShapeExpr' a -> Result
transShapeExpr x = case x of
  Bridgechai.Abs.ESuit _ suitlit -> failure x
  Bridgechai.Abs.EShapeInt _ integer -> failure x
  Bridgechai.Abs.ENotShape _ shapeexpr -> failure x
  Bridgechai.Abs.ERelShape _ shapeexpr1 relop shapeexpr2 -> failure x
  Bridgechai.Abs.EAndShape _ shapeexpr1 shapeexpr2 -> failure x
  Bridgechai.Abs.EOrShape _ shapeexpr1 shapeexpr2 -> failure x

transSuitLit :: Show a => Bridgechai.Abs.SuitLit' a -> Result
transSuitLit x = case x of
  Bridgechai.Abs.SuitLitS _ -> failure x
  Bridgechai.Abs.SuitLitH _ -> failure x
  Bridgechai.Abs.SuitLitD _ -> failure x
  Bridgechai.Abs.SuitLitC _ -> failure x

transHoldingExpr :: Show a => Bridgechai.Abs.HoldingExpr' a -> Result
transHoldingExpr x = case x of
  Bridgechai.Abs.HExprLen _ -> failure x
  Bridgechai.Abs.HExprInt _ integer -> failure x
  Bridgechai.Abs.HExprCard _ card -> failure x
  Bridgechai.Abs.HNotExpr _ holdingexpr -> failure x
  Bridgechai.Abs.HRelExpr _ holdingexpr1 relop holdingexpr2 -> failure x
  Bridgechai.Abs.HAndExpr _ holdingexpr1 holdingexpr2 -> failure x
  Bridgechai.Abs.HOrExpr _ holdingexpr1 holdingexpr2 -> failure x

transCard :: Show a => Bridgechai.Abs.Card' a -> Result
transCard x = case x of
  Bridgechai.Abs.CardA _ -> failure x
  Bridgechai.Abs.CardK _ -> failure x
  Bridgechai.Abs.CardQ _ -> failure x
  Bridgechai.Abs.CardJ _ -> failure x
  Bridgechai.Abs.CardT _ -> failure x
  Bridgechai.Abs.Card9 _ -> failure x
  Bridgechai.Abs.Card8 _ -> failure x
  Bridgechai.Abs.Card7 _ -> failure x
  Bridgechai.Abs.Card6 _ -> failure x
  Bridgechai.Abs.Card5 _ -> failure x
  Bridgechai.Abs.Card4 _ -> failure x
  Bridgechai.Abs.Card3 _ -> failure x
  Bridgechai.Abs.Card2 _ -> failure x

transRelOp :: Show a => Bridgechai.Abs.RelOp' a -> Result
transRelOp x = case x of
  Bridgechai.Abs.LTH _ -> failure x
  Bridgechai.Abs.LE _ -> failure x
  Bridgechai.Abs.GTH _ -> failure x
  Bridgechai.Abs.GE _ -> failure x
  Bridgechai.Abs.EQU _ -> failure x
  Bridgechai.Abs.NE _ -> failure x
